// TestAppConsole.cpp : A "Hello World" console sample application.
// This example creates a head-tracker using the first WDM driver supported camera found on the system,
// and shows the tracking in a window and provides the user with some simple keyboard commands.

// Precompiled header file
#include "stdafx.h"
// Some utilities for error handling, printing and console key-press interpreting etc.
#include "utils.h"
// For CTRL-C handling
#include <csignal>

// Here you can toggle behaviour to use either the synchronous head-pose callback (called when head-pose is changed) 
// or an asynchronous direct-call mechanism that reads the latest head-pose value.
// Comment out this define to use the direct-call mechanism.
#define USE_HEADPOSE_CALLBACK

using namespace std;
using namespace sm::faceapi::samplecode;

// --------------------------
// Notes on Callback Routines
// --------------------------
//
// The following callbacks are called by internal engine worker threads.
//
// These example routines lock a mutex to protect any data structures against read-write race-conditions, 
// or in the case of the receiveLogMessage() function, to serialize the calling threads to avoid
// garbled messages from being printed.
// 
// In these examples the mutex is just protecting a boolean which is a POD type and atomically
// read / written by the CPU, so it is there for example purposes only. In your real application code 
// you will want to copy the contents of the head-tracking data structures into your own data structures.
// These will not copy in one instruction so you will need to use a mutex to avoid weird noise from appearing 
// in the data (and then you will blame it on the tracker!)
// 
// The code below also illustrates that those faceAPI functions marked as "reentrant" can be called from 
// within the callback routines. All other faceAPI non-rentrant functions will incur deadlocks, BEWARE!

// Callback function for messages generated by API routines
void STDCALL receiveLogMessage(void *, const char *buf, int /*buf_len*/)
{
    Lock lock(g_mutex); // serialize logging calls from different threads to avoid garbled output.
    cout << string(buf);
}

// Callback function for face-data
void STDCALL receiveFaceData(void *, smEngineFaceData face_data, smCameraVideoFrame video_frame)
{   
    Lock lock(g_mutex);

    // Get info including data pointer to original image from camera
    smImageInfo video_frame_image_info;
    THROW_ON_ERROR(smImageGetInfo(video_frame.image_handle, &video_frame_image_info)); // reentrant, so ok

    // video_frame_image_info.plane_addr[*] now point to the image memory planes. 
    // The memory is only valid until the end of this routine unless you call smImageAddRef(video_frame.image_handle).
    // So you can deep copy the image data here, or use smImageAddRef() and just copy the pointer.
    // If you use smImageAddRef() you are responsible for calling smImageDestroy() to avoid a memory leak later.

    // In this callback you will typically want to copy the smEngineFaceData data into your own data-structure.
    // Since the smEngineFaceData contains multiple pod types copying it is not atomic and 
    // a mutex is required to avoid the race-condition with any thread simultaneously 
    // reading from your data-structure.
    // Such a race condition will not crash your code but will create weird noise in the tracking data.

    if (g_do_face_data_printing)
    {
        cout << video_frame << " " << face_data;

        // Save any face texture to a PNG file
        if (face_data.texture)
        {
            // Create a unique filename
            std::stringstream filename;
            filename << "face_" << video_frame.frame_num << ".png";        
            // Try saving to a file
            if (saveToPNGFile(filename.str(), face_data.texture->image_info) == SM_API_OK)
            {
                cout << "Saved face-texture to " << filename.str() << std::endl;
            }
            else
            {
                cout << "Error saving face-texture to " << filename.str() << std::endl;
            }
        }
    }
}

// Callback function for head-pose
void STDCALL receiveHeadPose(void *,smEngineHeadPoseData head_pose, smCameraVideoFrame video_frame)
{
    Lock lock(g_mutex);

    // Get info including data pointer to original image from camera
    smImageInfo video_frame_image_info;
    THROW_ON_ERROR(smImageGetInfo(video_frame.image_handle, &video_frame_image_info)); // reentrant, so ok

    // video_frame_image_info.plane_addr[*] now point to the image memory planes. 
    // The memory is only valid until the end of this routine unless you call smImageAddRef(video_frame.image_handle).
    // So you can deep copy the image data here, or use smImageAddRef() and just copy the pointer.
    // If you use smImageAddRef() you are responsible for calling smImageDestroy() to avoid a memory leak later.

    // In this callback you will typically want to copy the smEngineFaceData data into your own data-structure.
    // Since the smEngineFaceData contains multiple pod types copying it is not atomic and 
    // a mutex is required to avoid the race-condition with any thread simultaneously 
    // reading from your data-structure.
    // Such a race condition will not crash your code but will create weird noise in the tracking data.

    if (g_do_head_pose_printing)
    {
        cout << video_frame << " " << head_pose << std::endl;
    }
}

// Create the first available camera detected on the system, and return its handle
smCameraHandle createFirstCamera()
{
    // Detect cameras
    smCameraInfoList info_list;
    THROW_ON_ERROR(smCameraCreateInfoList(&info_list));

    if (info_list.num_cameras == 0)
    {
        throw runtime_error("No cameras were detected");
    }
    else
    {
        cout << "The followings cameras were detected: " << endl;
        for (int i=0; i<info_list.num_cameras; ++i)
        {
            char buf[1024];
            cout << "    " << i << ". Type: " << info_list.info[i].type;
            THROW_ON_ERROR(smStringWriteBuffer(info_list.info[i].model,buf,1024));
            cout << " Model: " << string(buf);
            cout << " Instance: " << info_list.info[i].instance_index << endl;
            // Print all the possible formats for the camera
            for (int j=0; j<info_list.info[i].num_formats; j++)
            {
                smCameraVideoFormat video_format = info_list.info[i].formats[j];
                cout << "     - Format: ";
                cout << " res (" << video_format.res.w << "," << video_format.res.h << ")";
                cout << " image code " << video_format.format;
                cout << " framerate " << video_format.framerate << "(hz)";
                cout << " upside-down? " << (video_format.is_upside_down ? "y":"n") << endl;
            }
        }
    }

    // Create the first camera detected on the system
    smCameraHandle camera_handle = 0;
    THROW_ON_ERROR(smCameraCreate(&info_list.info[0],   // Use first camera
                                  0,                    // Use default settings for lens
                                  &camera_handle));

    // Destroy the info list
    smCameraDestroyInfoList(&info_list);

    return camera_handle;
}

// The main function: setup a tracking engine and show a video window, then loop on the keyboard.
void run()
{
    // Capture control-C
    signal(SIGINT, CtrlCHandler);

    // Make the console window a bit bigger (see utils.h)
    initConsole();

#   ifdef _DEBUG
    // Log API debugging information to a file
    THROW_ON_ERROR(smLoggingSetFileOutputEnable(SM_API_TRUE));

    // Hook up log message callback
    THROW_ON_ERROR(smLoggingRegisterCallback(0,receiveLogMessage));
#   endif

    // Get the version
    int major, minor, maint;
    THROW_ON_ERROR(smAPIVersion(&major, &minor, &maint));
    cout << endl << "API VERSION: " << major << "." << minor << "." << maint << "." << endl << endl;
    // Print detailed license info
    char *buff;
    int size;
    THROW_ON_ERROR(smAPILicenseInfoString(0,&size,SM_API_TRUE));
    buff = new char[size];
    THROW_ON_ERROR(smAPILicenseInfoString(buff,&size,SM_API_TRUE));
    cout << "LICENSE: " << buff << endl << endl;
    // Determine if non-commercial restrictions apply
    const bool non_commercial_license = smAPINonCommercialLicense() == SM_API_TRUE;

    // Initialize the API
    THROW_ON_ERROR(smAPIInit());

#   ifdef _DEBUG
    // Get the path to the logfile
    smStringHandle logfile_path_handle = 0;
    THROW_ON_ERROR(smStringCreate(&logfile_path_handle));
    THROW_ON_ERROR(smLoggingGetPath(logfile_path_handle));
    int buf_len = 0;
    unsigned short *buf = 0;
    THROW_ON_ERROR(smStringGetBufferW(logfile_path_handle,(wchar_t **)&buf,&buf_len));
    wcout << "Writing log to file: " << wstring((wchar_t *)buf) << endl;
    THROW_ON_ERROR(smStringDestroy(&logfile_path_handle));
#   endif

    // Register the WDM category of cameras
    THROW_ON_ERROR(smCameraRegisterType(SM_API_CAMERA_TYPE_WDM));

    smEngineHandle engine_handle = 0;
    smCameraHandle camera_handle = 0;
    if (non_commercial_license)
    {
        // Create a new Head-Tracker engine that uses the camera
        THROW_ON_ERROR(smEngineCreate(SM_API_ENGINE_LATEST_HEAD_TRACKER,&engine_handle));
    }
    else
    {
        // Print out a list of connected cameras, and choose the first camera on the system
        camera_handle = createFirstCamera();
        // Create a new Head-Tracker engine that uses the camera
        THROW_ON_ERROR(smEngineCreateWithCamera(SM_API_ENGINE_LATEST_HEAD_TRACKER,camera_handle,&engine_handle));
    }

    // Check license for particular engine version (always ok for non-commercial license)
    const bool engine_licensed = smEngineIsLicensed(engine_handle) == SM_API_OK;

    cout << "-----------------------------------------------------" << endl;
    cout << "Press 'r' to restart tracking" << endl;
    cout << "Press 'a' to toggle auto-restart mode" << endl;
    if (!non_commercial_license)
    {
        cout << "Press 'l' to toggle lip-tracking" << endl;
        cout << "Press 'e' to toggle eyebrow-tracking" << endl;
    }
    if (engine_licensed)
    {
        cout << "Press 'h' to toggle printing of head-pose data" << endl;
        cout << "Press 'f' to toggle printing of face-landmark data" << endl;
    }
    cout << "Press '1' to toggle face coordinate frame axes" << endl;
    cout << "Press '2' to toggle performance info" << endl;
    cout << "Press '3' to toggle face mask" << endl;
    cout << "Press '4' to toggle face landmarks" << endl;
    cout << "Press CTRL-C or 'q' to quit" << endl;
    cout << "-----------------------------------------------------" << endl;

    // Hook up callbacks to receive output data from engine.
    // These functions will return errors if the engine is not licensed.
    if (engine_licensed)
    {
#       ifdef USE_HEADPOSE_CALLBACK
        THROW_ON_ERROR(smHTRegisterHeadPoseCallback(engine_handle,0,receiveHeadPose));
#       endif
        if (!non_commercial_license)
        {
            THROW_ON_ERROR(smHTRegisterFaceDataCallback(engine_handle,0,receiveFaceData));
        }
    }
    else
    {
        cout << "Engine is not licensed, cannot obtain any output data." << endl;
    }

    if (!non_commercial_license)
    {
        // Enable lip and eyebrow tracking
        THROW_ON_ERROR(smHTSetLipTrackingEnabled(engine_handle,SM_API_TRUE));
        THROW_ON_ERROR(smHTSetEyebrowTrackingEnabled(engine_handle,SM_API_TRUE));
    }

    // Create and show a video-display window
    smVideoDisplayHandle video_display_handle = 0;
    THROW_ON_ERROR(smVideoDisplayCreate(engine_handle,&video_display_handle,0,TRUE));

    // Setup the VideoDisplay
    THROW_ON_ERROR(smVideoDisplaySetFlags(video_display_handle,g_overlay_flags));

    // Get the handle to the window and change the title to "Hello World"
    smWindowHandle win_handle = 0;
    THROW_ON_ERROR(smVideoDisplayGetWindowHandle(video_display_handle,&win_handle));    
    SetWindowText(win_handle, _T("Hello World!"));

    // Start tracking
    THROW_ON_ERROR(smEngineStart(engine_handle));

    // Loop on the keyboard
    while (processKeyPress(engine_handle, video_display_handle))
    {
        // Read and print the current head-pose (if not using the callback mechanism)
#       ifndef USE_HEADPOSE_CALLBACK
        if (engine_licensed)
        {
            smEngineHeadPoseData head_pose;
            THROW_ON_ERROR(smHTCurrentHeadPose(engine_handle,&head_pose));
            Lock lock(g_mutex);
            if (g_do_head_pose_printing)
            {
                std::cout << head_pose << std::endl;
            }
        }
#       endif

        // NOTE: If you have a windows event loop in your program you 
        // will not need to call smAPIProcessEvents(). This manually redraws the video window.
        THROW_ON_ERROR(smAPIProcessEvents());

        // Prevent CPU overload in our simple loop.
        const int frame_period_ms = 33;
        Sleep(frame_period_ms); 
    }

    // Destroy engine
    THROW_ON_ERROR(smEngineDestroy(&engine_handle));
    // Destroy video display
    THROW_ON_ERROR(smVideoDisplayDestroy(&video_display_handle));
} // run()

// Application entry point
int _tmain(int /*argc*/, _TCHAR** /*argv*/)
{
    try
    {
        run();
    }
    catch (exception &e)
    {
        cerr << e.what() << endl;
    }
    return smAPIQuit();
}

