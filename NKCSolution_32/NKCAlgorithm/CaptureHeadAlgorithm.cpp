#include "stdafx.h"
#include "CaptureHeadAlgorithm.h"
// Some utilities for error handling, printing and console key-press interpreting etc.
#include "utils.h"
// For CTRL-C handling
#include <csignal>
#define USE_HEADPOSE_CALLBACK
//#define _DEBUG

using namespace std;
using namespace sm::faceapi::samplecode;

smEngineHandle engine_handle;
smCameraHandle camera_handle;
smVideoDisplayHandle video_display_handle;
smWindowHandle win_handle;

// Callback function for messages generated by API routines
void STDCALL receiveLogMessage(void *, const char *, int)
{
	Lock lock(g_mutex); // serialize logging calls from different threads to avoid garbled output.
	//cout << string(buf);
}

// Callback function for face-data
void STDCALL receiveFaceData(void *, smEngineFaceData face_data, smCameraVideoFrame video_frame)
{   
	Lock lock(g_mutex);

	// Get info including data pointer to original image from camera
	smImageInfo video_frame_image_info;
	THROW_ON_ERROR(smImageGetInfo(video_frame.image_handle, &video_frame_image_info)); // reentrant, so ok

	// video_frame_image_info.plane_addr[*] now point to the image memory planes. 
	// The memory is only valid until the end of this routine unless you call smImageAddRef(video_frame.image_handle).
	// So you can deep copy the image data here, or use smImageAddRef() and just copy the pointer.
	// If you use smImageAddRef() you are responsible for calling smImageDestroy() to avoid a memory leak later.

	// In this callback you will typically want to copy the smEngineFaceData data into your own data-structure.
	// Since the smEngineFaceData contains multiple pod types copying it is not atomic and 
	// a mutex is required to avoid the race-condition with any thread simultaneously 
	// reading from your data-structure.
	// Such a race condition will not crash your code but will create weird noise in the tracking data.

	if (g_do_face_data_printing)
	{
		cout << video_frame << " " << face_data;

		// Save any face texture to a PNG file
		if (face_data.texture)
		{
			// Create a unique filename
			std::stringstream filename;
			filename << "face_" << video_frame.frame_num << ".png";        
			// Try saving to a file
			if (saveToPNGFile(filename.str(), face_data.texture->image_info) == SM_API_OK)
			{
				cout << "Saved face-texture to " << filename.str() << std::endl;
			}
			else
			{
				cout << "Error saving face-texture to " << filename.str() << std::endl;
			}
		}
	}
}

// Callback function for head-pose
void STDCALL receiveHeadPose(void *,smEngineHeadPoseData head_pose, smCameraVideoFrame video_frame)
{
	Lock lock(g_mutex);

	// Get info including data pointer to original image from camera
	smImageInfo video_frame_image_info;
	THROW_ON_ERROR(smImageGetInfo(video_frame.image_handle, &video_frame_image_info)); // reentrant, so ok

	// video_frame_image_info.plane_addr[*] now point to the image memory planes. 
	// The memory is only valid until the end of this routine unless you call smImageAddRef(video_frame.image_handle).
	// So you can deep copy the image data here, or use smImageAddRef() and just copy the pointer.
	// If you use smImageAddRef() you are responsible for calling smImageDestroy() to avoid a memory leak later.

	// In this callback you will typically want to copy the smEngineFaceData data into your own data-structure.
	// Since the smEngineFaceData contains multiple pod types copying it is not atomic and 
	// a mutex is required to avoid the race-condition with any thread simultaneously 
	// reading from your data-structure.
	// Such a race condition will not crash your code but will create weird noise in the tracking data.

	if (g_do_head_pose_printing)
	{
		cout << video_frame << " " << head_pose << std::endl;
	}
}

// Create the first available camera detected on the system, and return its handle
smCameraHandle createFirstCamera()
{
	// Detect cameras
	smCameraInfoList info_list;
	THROW_ON_ERROR(smCameraCreateInfoList(&info_list));

	if (info_list.num_cameras == 0)
	{
		throw runtime_error("No cameras were detected");
	}
	else
	{
		cout << "The followings cameras were detected: " << endl;
		for (int i=0; i<info_list.num_cameras; ++i)
		{
			char buf[1024];
			cout << "    " << i << ". Type: " << info_list.info[i].type;
			THROW_ON_ERROR(smStringWriteBuffer(info_list.info[i].model,buf,1024));
			cout << " Model: " << string(buf);
			cout << " Instance: " << info_list.info[i].instance_index << endl;
			// Print all the possible formats for the camera
			for (int j=0; j<info_list.info[i].num_formats; j++)
			{
				smCameraVideoFormat video_format = info_list.info[i].formats[j];
				cout << "     - Format: ";
				cout << " res (" << video_format.res.w << "," << video_format.res.h << ")";
				cout << " image code " << video_format.format;
				cout << " framerate " << video_format.framerate << "(hz)";
				cout << " upside-down? " << (video_format.is_upside_down ? "y":"n") << endl;
			}
		}
	}

	// Create the first camera detected on the system
	smCameraHandle camera_handle = 0;
	THROW_ON_ERROR(smCameraCreate(&info_list.info[0],   // Use first camera
		0,                    // Use default settings for lens
		&camera_handle));

	// Destroy the info list
	smCameraDestroyInfoList(&info_list);

	return camera_handle;
}



CaptureHeadAlgorithm::CaptureHeadAlgorithm(void)
{
	engine_handle = 0;
	camera_handle = 0;	
	win_handle = 0;
	video_display_handle = 0;
}


CaptureHeadAlgorithm::~CaptureHeadAlgorithm(void)
{
}

bool CaptureHeadAlgorithm::end()
{
	// Destroy engine
	THROW_ON_ERROR(smEngineDestroy(&engine_handle));

	// Destroy video display
	THROW_ON_ERROR(smVideoDisplayDestroy(&video_display_handle));
	smAPIQuit();
	return true;
}


bool CaptureHeadAlgorithm::init()
{
	// Capture control-C
	//signal(SIGINT, CtrlCHandler);

	// Make the console window a bit bigger (see utils.h)
#	ifdef _DEBUG
	initConsole();
	// Log API debugging information to a file
	THROW_ON_ERROR(smLoggingSetFileOutputEnable(SM_API_TRUE));

	// Hook up log message callback
	THROW_ON_ERROR(smLoggingRegisterCallback(0,receiveLogMessage));
#   endif

	// Get the version
#	ifdef _DEBUG
	int major, minor, maint;
	THROW_ON_ERROR(smAPIVersion(&major, &minor, &maint));
	cout << endl << "API VERSION: " << major << "." << minor << "." << maint << "." << endl << endl;
#	endif
	// Print detailed license info
	// Determine if non-commercial restrictions apply
	const bool non_commercial_license = smAPINonCommercialLicense() == SM_API_TRUE;

	// Initialize the API
	THROW_ON_ERROR(smAPIInit());

#   ifdef _DEBUG
	// Get the path to the logfile
	smStringHandle logfile_path_handle = 0;
	THROW_ON_ERROR(smStringCreate(&logfile_path_handle));
	THROW_ON_ERROR(smLoggingGetPath(logfile_path_handle));
	int buf_len = 0;
	unsigned short *buf = 0;
	THROW_ON_ERROR(smStringGetBufferW(logfile_path_handle,(wchar_t **)&buf,&buf_len));
	wcout << "Writing log to file: " << wstring((wchar_t *)buf) << endl;
	THROW_ON_ERROR(smStringDestroy(&logfile_path_handle));
#   endif

	// Register the WDM category of cameras
	THROW_ON_ERROR(smCameraRegisterType(SM_API_CAMERA_TYPE_WDM));

	if (non_commercial_license)
	{
		// Create a new Head-Tracker engine that uses the camera
		THROW_ON_ERROR(smEngineCreate(SM_API_ENGINE_LATEST_HEAD_TRACKER,&engine_handle));
	}
	else
	{
		// Print out a list of connected cameras, and choose the first camera on the system
		camera_handle = createFirstCamera();
		// Create a new Head-Tracker engine that uses the camera
		THROW_ON_ERROR(smEngineCreateWithCamera(SM_API_ENGINE_LATEST_HEAD_TRACKER,camera_handle,&engine_handle));
	}

	// Check license for particular engine version (always ok for non-commercial license)
	const bool engine_licensed = smEngineIsLicensed(engine_handle) == SM_API_OK;

	// Hook up callbacks to receive output data from engine.
	// These functions will return errors if the engine is not licensed.
	if (engine_licensed)
	{
#       ifdef USE_HEADPOSE_CALLBACK
		THROW_ON_ERROR(smHTRegisterHeadPoseCallback(engine_handle,0,receiveHeadPose));
#       endif
		if (!non_commercial_license)
		{
			THROW_ON_ERROR(smHTRegisterFaceDataCallback(engine_handle,0,receiveFaceData));
		}
	}
	else
	{
		cout << "Engine is not licensed, cannot obtain any output data." << endl;
	}

	if (!non_commercial_license)
	{
		// Enable lip and eyebrow tracking
		THROW_ON_ERROR(smHTSetLipTrackingEnabled(engine_handle,SM_API_TRUE));
		THROW_ON_ERROR(smHTSetEyebrowTrackingEnabled(engine_handle,SM_API_TRUE));
	}

#	ifdef _DEBUG
	/*
	// Create and show a video-display window
	smVideoDisplayHandle video_display_handle = 0;
	THROW_ON_ERROR(smVideoDisplayCreate(engine_handle,&video_display_handle,0,TRUE));

	// Setup the VideoDisplay
	THROW_ON_ERROR(smVideoDisplaySetFlags(video_display_handle,g_overlay_flags));

	// Get the handle to the window and change the title to "Hello World"
	smWindowHandle win_handle = 0;
	THROW_ON_ERROR(smVideoDisplayGetWindowHandle(video_display_handle,&win_handle));    
	SetWindowText(win_handle, _T("DEBUG_MOD"));
	*/
#	endif
	return true;
}

bool CaptureHeadAlgorithm::start()
{
	init();
	// Start tracking
	THROW_ON_ERROR(smEngineStart(engine_handle));
	return true;
}
bool CaptureHeadAlgorithm::stop()
{
	// Start tracking
	//THROW_ON_ERROR(smEngineStop(engine_handle));
	end();
	return true;
}
bool CaptureHeadAlgorithm::getpos(HeadState &state)//开始更新，1为异常退出，0为正常
{
	// Loop on the keyboard
	//while (processKeyPress(engine_handle, video_display_handle))

	// Read and print the current head-pose (if not using the callback mechanism)
#       ifndef USE_HEADPOSE_CALLBACK
	if (engine_licensed)
	{
		smEngineHeadPoseData head_pose;
		THROW_ON_ERROR(smHTCurrentHeadPose(engine_handle,&head_pose));
		Lock lock(g_mutex);
		std::cout << head_pose << std::endl;
	}
#       endif

	// NOTE: If you have a windows event loop in your program you 
	// will not need to call smAPIProcessEvents(). This manually redraws the video window.
	THROW_ON_ERROR(smAPIProcessEvents());


	smEngineHeadPoseData head_pose;
	THROW_ON_ERROR(smHTCurrentHeadPose(engine_handle,&head_pose));
	Lock lock(g_mutex);
	state.head_x = head_pose.head_pos.x;
	state.head_y = head_pose.head_pos.y;
	state.head_z = head_pose.head_pos.z;

	state.angle_x = head_pose.head_rot.x_rads;
	state.angle_y = head_pose.head_rot.y_rads;
	state.angle_z = head_pose.head_rot.z_rads;

	// Prevent CPU overload in our simple loop.
	//const int frame_period_ms = 11;
	//Sleep(frame_period_ms); 
	return true;
}

